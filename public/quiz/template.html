<!doctype html>
<html lang="ko">
  <head>
    <script src="/config.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js"></script>
    <script src="/app.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>퀴즈 참가</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header class="header"><h1 id="quizTitle">퀴즈 참가</h1></header>

    <main style="padding: 1.25rem; flex: 1">
      <section id="nicknameSection" class="card" aria-label="닉네임 입력">
        <label for="nicknameInput">닉네임</label>
        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem">
          <input
            id="nicknameInput"
            type="text"
            placeholder="닉네임을 입력하세요"
            class="input-text"
            aria-label="닉네임 입력"
          />
          <button id="joinBtn" class="btn-primary">참가</button>
        </div>
        <p style="color: var(--muted); margin-top: 0.5rem">
          이 사이트는 IP/localStorage로 세션을 보존합니다. 새로고침해도
          진행/점수가 유지됩니다.
        </p>
      </section>

      <section
        id="questionBox"
        class="card"
        aria-live="polite"
        style="display: none"
      >
        <h2 id="questionText"></h2>
        <img
          id="questionImage"
          style="
            max-width: 320px;
            display: none;
            margin: 0.5rem auto;
            border-radius: 8px;
          "
          alt="문제 이미지"
        />
        <div id="answers"></div>

        <div id="timer" style="margin-top: 0.6rem">
          ⏳ 남은 시간: <span id="timeLeft">0</span>s
        </div>
        <div id="scoreHint" style="margin-top: 0.4rem; color: var(--muted)">
          빠르게 맞출수록 점수가 큽니다. 두 배 문제는 표시됩니다.
        </div>

        <div id="feedback" style="margin-top: 0.6rem; font-weight: 700"></div>
      </section>
    </main>

    <footer class="footer">© 2025 QuizMaker</footer>

    <script>
      const slug = window.location.pathname.split("/").pop();

      // DOM
      const nicknameInput = document.getElementById("nicknameInput");
      const joinBtn = document.getElementById("joinBtn");
      const nicknameSection = document.getElementById("nicknameSection");
      const questionBox = document.getElementById("questionBox");
      const questionText = document.getElementById("questionText");
      const questionImage = document.getElementById("questionImage");
      const answersEl = document.getElementById("answers");
      const timeLeftEl = document.getElementById("timeLeft");
      const feedbackEl = document.getElementById("feedback");

      // state
      let playerId = localStorage.getItem("playerId") || null;
      let nicknameStored = localStorage.getItem("nickname") || null;
      let gameId = null;
      let currentQuestion = null;
      let timerInterval = null;
      let questionStartTime = null;

      // local progression state (참가자 개별 진행)
      let _localQuestions = [];
      let _localIndex = 0;

      // helper: get or create game record by slug
      async function ensureGameRecord() {
        const { data: game } = await db
          .from("games")
          .select("id,started,current_question_ord,ended,quiz_id")
          .eq("slug", slug)
          .maybeSingle();
        if (!game) return null;
        gameId = game.id;
        return game;
      }

      // join / session restore
      async function joinGame() {
        try {
          const game = await ensureGameRecord();
          if (!game) {
            safeAlert("아직 호스트가 게임을 생성하지 않았습니다.");
            return;
          }

          if (playerId) {
            const { data: p } = await db
              .from("players")
              .select("*")
              .eq("id", playerId)
              .maybeSingle();
            if (p && p.game_id === gameId) {
              nicknameStored = p.nickname;
              nicknameInput.value = nicknameStored;
              nicknameSection.style.display = "none";
              questionBox.style.display = "block";

              // 참가자는 전체 문제 목록을 로컬로 로드하여 개별 진행
              const { data: questions } = await db
                .from("questions")
                .select(
                  "id,ord,text,image_url,timeout,double_points,answers(*)",
                )
                .eq("quiz_id", game.quiz_id)
                .order("ord");
              _localQuestions = questions || [];

              subscribeGame(gameId);

              // 게임이 이미 시작되었으면 개인 진행 시작
              if (game.started) startLocalQuiz();
              else {
                questionText.textContent =
                  "호스트가 시작할 때까지 대기 중입니다...";
              }
              return;
            } else {
              localStorage.removeItem("playerId");
              playerId = null;
            }
          }

          const nickname = nicknameInput.value.trim();
          if (!nickname) {
            safeAlert("닉네임을 입력하세요.");
            return;
          }

          const { data: newPlayer, error } = await db
            .from("players")
            .insert([{ game_id: gameId, nickname, points: 0 }])
            .select()
            .single();
          if (error) throw error;
          playerId = newPlayer.id;
          localStorage.setItem("playerId", playerId);
          localStorage.setItem("nickname", nickname);
          nicknameSection.style.display = "none";
          questionBox.style.display = "block";

          // 참가자는 전체 문제 목록을 로컬로 로드하여 개별 진행
          const { data: questions } = await db
            .from("questions")
            .select("id,ord,text,image_url,timeout,double_points,answers(*)")
            .eq("quiz_id", game.quiz_id)
            .order("ord");
          _localQuestions = questions || [];

          subscribeGame(gameId);

          // 게임이 이미 시작되었으면 개인 진행 시작
          if (game.started) startLocalQuiz();
          else {
            questionText.textContent =
              "호스트가 시작할 때까지 대기 중입니다...";
          }
        } catch (err) {
          console.error("joinGame error", err);
          safeAlert("참가 실패: " + (err.message || err));
        }
      }

      joinBtn.addEventListener("click", joinGame);

      function subscribeGame(gameIdLocal) {
        db.channel("games-" + gameIdLocal)
          .on(
            "postgres_changes",
            {
              event: "UPDATE",
              schema: "public",
              table: "games",
              filter: `id=eq.${gameIdLocal}`,
            },
            (payload) => {
              const g = payload.new;
              if (g.ended) {
                window.location.href = `/quiz/${slug}/leaderboard`;
              }
              // 호스트가 started를 true로 설정하면 개인 진행 시작
              if (g.started) {
                // only start if local questions exist
                if (_localQuestions && _localQuestions.length > 0) {
                  startLocalQuiz();
                } else {
                  // attempt to fetch questions if not loaded yet
                  (async () => {
                    const { data: game } = await db
                      .from("games")
                      .select("quiz_id")
                      .eq("id", gameId)
                      .single();
                    const { data: questions } = await db
                      .from("questions")
                      .select(
                        "id,ord,text,image_url,timeout,double_points,answers(*)",
                      )
                      .eq("quiz_id", game.quiz_id)
                      .order("ord");
                    _localQuestions = questions || [];
                    if (_localQuestions.length > 0) startLocalQuiz();
                  })();
                }
              }
            },
          )
          .subscribe();
      }

      // --- 개인 진행 로직: startLocalQuiz / renderLocalQuestion / submitAnswerAndNext ---
      function startLocalQuiz() {
        _localIndex = 0;
        if (!Array.isArray(_localQuestions) || _localQuestions.length === 0) {
          questionText.textContent = "문제가 없습니다.";
          return;
        }
        renderLocalQuestion(_localIndex);
      }

      function renderLocalQuestion(idx) {
        const question = _localQuestions[idx];
        if (!question) {
          // 개인 완료: 리더보드로 이동 (호스트가 아직 모든 참가자 완료를 기다리는 경우도 있고,
          // 호스트의 checkAllFinished가 동작하면 전체 리더보드 페이지로 이동됩니다)
          window.location.href = `/quiz/${slug}/leaderboard`;
          return;
        }
        currentQuestion = question;
        renderQuestionLocal(question);
      }

      // 렌더링 함수: 기존 renderQuestion과 유사하지만 'question' 구조는 answers 포함
      async function renderQuestionLocal(question) {
        // reuse current render UI
        questionText.textContent = question.text || "(문제 없음)";
        if (question.image_url) {
          questionImage.src = question.image_url;
          questionImage.style.display = "block";
        } else {
          questionImage.style.display = "none";
        }

        answersEl.innerHTML = "";
        // answers may be nested under question.answers
        const answers = question.answers || [];
        answers.forEach((a) => {
          const btn = document.createElement("button");
          btn.className = "answer-btn";
          btn.textContent = a.text || "보기";
          btn.onclick = () => submitAnswerAndNext(question, a);
          answersEl.appendChild(btn);
        });

        // start timer for this local question
        clearTimer();
        questionStartTime = Date.now();
        startTimer(question.timeout || 30, () => {
          // timeout -> auto submit null (오답) and advance
          submitAnswerAndNext(question, null);
        });
      }

      // wrapper: 제출 후 개인 인덱스 증가 및 다음 문제 렌더
      async function submitAnswerAndNext(question, answerObj) {
        // call existing submitAnswer (which writes player_answers and updates points)
        await submitAnswer(question, answerObj);

        // advance local index
        _localIndex += 1;
        // small delay for feedback readability
        setTimeout(() => {
          renderLocalQuestion(_localIndex);
        }, 600);
      }

      // 기존 init/render/submit 함수를 일부 재사용(아래)
      async function initQuestion(ord) {
        // 기존 서버-driven initQuestion은 더 이상 모든 참가자 강제 이동에 사용하지 않음.
        // 대신, 남아있는 코드와 호환되도록 빈 대기 표시 처리만 수행합니다.
        clearTimer();
        feedbackEl.textContent = "";
        if (ord === null || ord === undefined || ord < 0) {
          questionText.textContent = "호스트가 시작하면 문제가 나옵니다.";
          questionImage.style.display = "none";
          answersEl.innerHTML = "";
          timeLeftEl.textContent = "0";
          return;
        }

        // (호스트가 current_question_ord를 바꾸는 용도로 쓰이지 않으므로 이 함수는
        // 보조적인 역할만 합니다. 실제 문제 진행은 local progression으로 합니다.)
        // 여기서는 안전을 위해 만약 localQuestions 비어있다면 불러오는 시도를 합니다.
        try {
          if (!Array.isArray(_localQuestions) || _localQuestions.length === 0) {
            const { data: game } = await db
              .from("games")
              .select("quiz_id")
              .eq("id", gameId)
              .single();
            const { data: questions } = await db
              .from("questions")
              .select("id,ord,text,image_url,timeout,double_points,answers(*)")
              .eq("quiz_id", game.quiz_id)
              .order("ord");
            _localQuestions = questions || [];
          }
        } catch (e) {
          console.warn("initQuestion fallback fetch err", e);
        }
      }

      async function renderQuestion(question) {
        // 이 함수은 server-driven 흐름에서 호출될 수 있으나,
        // 이번 수정에서는 참가자 개인 진행에서 renderQuestionLocal을 사용합니다.
        // 남겨두어 호환성을 유지합니다.
        questionText.textContent = question.text || "(문제 없음)";
        if (question.image_url) {
          questionImage.src = question.image_url;
          questionImage.style.display = "block";
        } else {
          questionImage.style.display = "none";
        }

        answersEl.innerHTML = "";
        const { data: answers } = await db
          .from("answers")
          .select("*")
          .eq("question_id", question.id)
          .order("ord");
        answers.forEach((a) => {
          const btn = document.createElement("button");
          btn.className = "answer-btn";
          btn.textContent = a.text || "보기";
          btn.onclick = () => submitAnswerAndNext(question, a); // 변경: local flow 사용
          answersEl.appendChild(btn);
        });

        clearTimer();
        questionStartTime = Date.now();
        startTimer(question.timeout || 30, () => {
          submitAnswerAndNext(question, null);
        });
      }

      function startTimer(seconds, onTimeout) {
        clearTimer();
        let left = seconds;
        timeLeftEl.textContent = left;
        questionStartTime = Date.now();
        timerInterval = setInterval(() => {
          left -= 1;
          timeLeftEl.textContent = left;
          if (left <= Math.max(0, Math.floor(seconds * 0.35))) {
            timeLeftEl.classList.add("timer-danger");
          } else {
            timeLeftEl.classList.remove("timer-danger");
          }
          if (left <= 0) {
            clearTimer();
            onTimeout && onTimeout();
          }
        }, 1000);
      }
      function clearTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      async function submitAnswer(question, answerObj) {
        // 기존 로직 재사용: DB에 player_answers 삽입하고 RPC로 점수 증가 처리
        clearTimer();
        try {
          const timeTaken = Date.now() - (questionStartTime || Date.now());
          let selectedId = answerObj ? answerObj.id : null;
          let isCorrect = answerObj ? !!answerObj.is_correct : false;
          let score = 0;
          if (isCorrect) {
            const timeoutMs = (question.timeout || 30) * 1000;
            const base = 1000;
            const ratio = Math.max(0, Math.min(1, 1 - timeTaken / timeoutMs));
            const bonus = Math.max(200, Math.floor(700 * ratio));
            score = base + bonus;
            if (question.double_points) score *= 2;
          }

          const payload = {
            player_id: playerId,
            question_id: question.id,
            answer_id: selectedId,
            correct: isCorrect,
            time_ms: Math.floor(timeTaken),
            score,
          };
          const { error: insertErr } = await db
            .from("player_answers")
            .insert([payload]);
          if (insertErr)
            console.warn("player_answers insert error:", insertErr);

          if (score > 0) {
            const { error: rpcErr } = await db.rpc("increment_points", {
              pid: playerId,
              pscore: score,
            });
            if (rpcErr) console.warn("increment_points RPC error:", rpcErr);
          }

          feedbackEl.textContent = isCorrect ? `정답! +${score}점` : `오답 😭`;
        } catch (err) {
          console.error("submitAnswer err", err);
          safeAlert("제출 실패: " + (err.message || err));
        }
      }

      function safeAlert(m) {
        try {
          alert(m);
        } catch (e) {
          console.log(m);
        }
      }

      (async () => {
        if (localStorage.getItem("nickname")) {
          nicknameInput.value = localStorage.getItem("nickname");
        }
        if (localStorage.getItem("playerId")) {
          await joinGame();
        }
      })();
    </script>
  </body>
</html>
