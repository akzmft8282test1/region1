<!doctype html>
<html lang="ko">
  <head>
    <script src="/config.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js"></script>
    <script src="/app.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>퀴즈 참가</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header class="header"><h1 id="quizTitle">퀴즈 참가</h1></header>

    <main style="padding: 1.25rem; flex: 1">
      <section id="nicknameSection" class="card" aria-label="닉네임 입력">
        <label for="nicknameInput">닉네임</label>
        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem">
          <input
            id="nicknameInput"
            type="text"
            placeholder="닉네임을 입력하세요"
            class="input-text"
            aria-label="닉네임 입력"
          />
          <button id="joinBtn" class="btn-primary">참가</button>
        </div>
        <p style="color: var(--muted); margin-top: 0.5rem">
          이 사이트는 IP/localStorage로 세션을 보존합니다. 새로고침해도
          진행/점수가 유지됩니다.
        </p>
      </section>

      <section
        id="questionBox"
        class="card"
        aria-live="polite"
        style="display: none"
      >
        <h2 id="questionText"></h2>
        <img
          id="questionImage"
          style="
            max-width: 320px;
            display: none;
            margin: 0.5rem auto;
            border-radius: 8px;
          "
          alt="문제 이미지"
        />
        <div id="answers"></div>

        <div id="timer" style="margin-top: 0.6rem">
          ⏳ 남은 시간: <span id="timeLeft">0</span>s
        </div>
        <div id="scoreHint" style="margin-top: 0.4rem; color: var(--muted)">
          빠르게 맞출수록 점수가 큽니다. 두 배 문제는 표시됩니다.
        </div>

        <div id="feedback" style="margin-top: 0.6rem; font-weight: 700"></div>
      </section>
    </main>

    <footer class="footer">© 2025 QuizMaker</footer>

    <script>
      // Supabase init
      const supabase = window.supabase.createClient(
        window.__SUPABASE_URL__,
        window.__SUPABASE_KEY__,
      );

      const slug = window.location.pathname.split("/").pop();

      // DOM
      const nicknameInput = document.getElementById("nicknameInput");
      const joinBtn = document.getElementById("joinBtn");
      const nicknameSection = document.getElementById("nicknameSection");
      const questionBox = document.getElementById("questionBox");
      const questionText = document.getElementById("questionText");
      const questionImage = document.getElementById("questionImage");
      const answersEl = document.getElementById("answers");
      const timeLeftEl = document.getElementById("timeLeft");
      const feedbackEl = document.getElementById("feedback");

      // state
      let playerId = localStorage.getItem("playerId") || null;
      let nicknameStored = localStorage.getItem("nickname") || null;
      let gameId = null;
      let currentQuestion = null;
      let timerInterval = null;
      let questionStartTime = null;

      // helper: get or create game record by slug
      async function ensureGameRecord() {
        const { data: game } = await supabase
          .from("games")
          .select("id,started,current_question_ord,ended,quiz_id")
          .eq("slug", slug)
          .maybeSingle();
        if (!game) return null;
        gameId = game.id;
        return game;
      }

      // join / session restore
      async function joinGame() {
        try {
          // ensure game
          const game = await ensureGameRecord();
          if (!game) {
            safeAlert("아직 호스트가 게임을 생성하지 않았습니다.");
            return;
          }

          // if we have playerId in localStorage, try to fetch and reuse
          if (playerId) {
            const { data: p } = await supabase
              .from("players")
              .select("*")
              .eq("id", playerId)
              .maybeSingle();
            if (p && p.game_id === gameId) {
              nicknameStored = p.nickname;
              nicknameInput.value = nicknameStored;
              nicknameSection.style.display = "none";
              questionBox.style.display = "block";
              subscribeGame(gameId);
              initQuestion(game.current_question_ord);
              return;
            } else {
              // stale id: clear
              localStorage.removeItem("playerId");
              playerId = null;
            }
          }

          // new join
          const nickname = nicknameInput.value.trim();
          if (!nickname) {
            safeAlert("닉네임을 입력하세요.");
            return;
          }

          // insert player
          const { data: newPlayer, error } = await supabase
            .from("players")
            .insert([{ game_id: gameId, nickname, points: 0 }])
            .select()
            .single();
          if (error) throw error;
          playerId = newPlayer.id;
          localStorage.setItem("playerId", playerId);
          localStorage.setItem("nickname", nickname);
          nicknameSection.style.display = "none";
          questionBox.style.display = "block";
          subscribeGame(gameId);
          initQuestion(game.current_question_ord);
        } catch (err) {
          console.error("joinGame error", err);
          safeAlert("참가 실패: " + (err.message || err));
        }
      }

      joinBtn.addEventListener("click", joinGame);

      // subscribe to games updates
      function subscribeGame(gameIdLocal) {
        // subscribe to games updates for current game
        supabase
          .channel("games-" + gameIdLocal)
          .on(
            "postgres_changes",
            {
              event: "UPDATE",
              schema: "public",
              table: "games",
              filter: `id=eq.${gameIdLocal}`,
            },
            (payload) => {
              const g = payload.new;
              if (g.ended) {
                window.location.href = `/quiz/${slug}/leaderboard`;
              }
              // if current_question_ord changed, load it
              if (typeof g.current_question_ord === "number") {
                initQuestion(g.current_question_ord);
              }
            },
          )
          .subscribe();
      }

      // initQuestion: load and display question by ord (if ord <0 or null -> waiting)
      async function initQuestion(ord) {
        clearTimer();
        feedbackEl.textContent = "";
        if (ord === null || ord === undefined || ord < 0) {
          // waiting state
          questionText.textContent = "호스트가 시작하면 문제가 나옵니다.";
          questionImage.style.display = "none";
          answersEl.innerHTML = "";
          timeLeftEl.textContent = "0";
          return;
        }

        try {
          // find quiz id
          const { data: game } = await supabase
            .from("games")
            .select("quiz_id")
            .eq("id", gameId)
            .single();
          if (!game) return;
          const { data: question } = await supabase
            .from("questions")
            .select("id,text,image_url,timeout,double_points,ord")
            .eq("quiz_id", game.quiz_id)
            .eq("ord", ord)
            .maybeSingle();
          if (!question) {
            // no question at this ord -> maybe game over
            window.location.href = `/quiz/${slug}/leaderboard`;
            return;
          }
          currentQuestion = question;
          renderQuestion(question);
        } catch (err) {
          console.error("initQuestion err", err);
        }
      }

      // render question and start timer
      async function renderQuestion(question) {
        questionText.textContent = question.text || "(문제 없음)";
        if (question.image_url) {
          questionImage.src = question.image_url;
          questionImage.style.display = "block";
        } else {
          questionImage.style.display = "none";
        }

        answersEl.innerHTML = "";
        const { data: answers } = await supabase
          .from("answers")
          .select("*")
          .eq("question_id", question.id)
          .order("ord");
        // shuffle if quiz setting requires? (we do not auto-shuffle here unless quiz.settings)
        answers.forEach((a) => {
          const btn = document.createElement("button");
          btn.className = "answer-btn";
          btn.textContent = a.text || "보기";
          btn.onclick = () => submitAnswer(question, a);
          answersEl.appendChild(btn);
        });

        // timer
        startTimer(question.timeout || 30, () => {
          // on timeout -> submit as no answer (null)
          submitAnswer(question, null);
        });
      }

      function startTimer(seconds, onTimeout) {
        clearTimer();
        let left = seconds;
        timeLeftEl.textContent = left;
        questionStartTime = Date.now();
        timerInterval = setInterval(() => {
          left -= 1;
          timeLeftEl.textContent = left;
          if (left <= Math.max(0, Math.floor(seconds * 0.35))) {
            timeLeftEl.classList.add("timer-danger");
          } else {
            timeLeftEl.classList.remove("timer-danger");
          }
          if (left <= 0) {
            clearTimer();
            onTimeout && onTimeout();
          }
        }, 1000);
      }
      function clearTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      // submitAnswer: answerObj may be null (timeout) or answer record
      async function submitAnswer(question, answerObj) {
        clearTimer();
        try {
          const timeTaken = Date.now() - (questionStartTime || Date.now());
          let selectedId = answerObj ? answerObj.id : null;
          // find correct flag (if answerObj available)
          let isCorrect = false;
          if (answerObj && typeof answerObj.is_correct !== "undefined")
            isCorrect = !!answerObj.is_correct;
          // calculate score
          let score = 0;
          if (isCorrect) {
            const timeoutMs = (question.timeout || 30) * 1000;
            const base = 1000;
            const ratio = Math.max(0, Math.min(1, 1 - timeTaken / timeoutMs));
            const bonus = Math.max(200, Math.floor(700 * ratio)); // 200~900
            score = base + bonus;
            if (question.double_points) score *= 2;
          }

          // insert player_answers (answer_id may be null)
          const payload = {
            player_id: playerId,
            question_id: question.id,
            answer_id: selectedId,
            correct: isCorrect,
            time_ms: Math.floor(timeTaken),
            score,
          };
          const { error: insertErr } = await supabase
            .from("player_answers")
            .insert([payload]);
          if (insertErr)
            console.warn("player_answers insert error:", insertErr);

          // increment points via RPC
          if (score > 0) {
            const { error: rpcErr } = await supabase.rpc("increment_points", {
              pid: playerId,
              pscore: score,
            });
            if (rpcErr) console.warn("increment_points RPC error:", rpcErr);
          }

          feedbackEl.textContent = isCorrect
            ? `정답! +${score}점`
            : `오답 ${isCorrect ? "" : "😭"}`;
        } catch (err) {
          console.error("submitAnswer err", err);
          safeAlert("제출 실패: " + (err.message || err));
        }
      }

      function safeAlert(m) {
        try {
          alert(m);
        } catch (e) {
          console.log(m);
        }
      }

      // initialize: if localStorage has nickname, set field
      (async () => {
        if (localStorage.getItem("nickname")) {
          nicknameInput.value = localStorage.getItem("nickname");
        }
        // attempt to auto join if playerId exists
        if (localStorage.getItem("playerId")) {
          // try auto join
          await joinGame();
        }
      })();
    </script>
  </body>
</html>
